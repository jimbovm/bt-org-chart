/*
 * This source file was generated by the Gradle 'init' task
 */
package com.github.jimbovm.bt.orgchart;

import java.io.IOException;
import java.util.List;
import java.util.Optional;
import java.util.logging.Logger;
import java.util.regex.Pattern;

import com.github.jimbovm.bt.orgchart.parser.Parser;

public final class App {

	static {
		System.setProperty("java.util.logging.config.file", "logging.properties");
	}

	/** Return code to exit with on a successful result. */
	private static final int EXIT_SUCCESS = 0;

	/** Return code to exit on in the event of an error. */
	private static final int EXIT_FAILURE = 1;

	/** Command line argument index to the path to the input file. */
	private static final int FILE_PATH = 0;

	/** Command line argument index to the first employee name. */
	private static final int EMPLOYEE_1 = 1;

	/** Command line argument index to the second employee name. */
	private static final int EMPLOYEE_2 = 2;

	/** Cached path to the input file. */
	private static String filePath;

	/** The normalized name of the first employee. */
	private static String firstEmployeeName;

	/** The normalized name of the second employee. */
	private static String secondEmployeeName;

	/** The global logger. */
	private static Logger logger = Logger.getGlobal();

	/**
	 * Normalize a name by replacing all runs of whitespace with a single space,
	 * 
	 * @param name The name to normalize.
	 * @return The normalized name.
	 */
	public static String normalizeName(String name) {

		var whitespaceReplacementPattern = Pattern.compile("\s+",
				Pattern.UNICODE_CASE | Pattern.UNICODE_CHARACTER_CLASS);
		var matcher = whitespaceReplacementPattern.matcher(name);

		var whitespaceNormalizedString = matcher.replaceAll(name);
		return whitespaceNormalizedString.strip().replaceAll("\\s+", " ").toLowerCase();
	}

	public static boolean containsName(List<Employee> employees, String name) {
		return employees.stream().anyMatch(employee -> normalizeName(employee.name()) == name);
	}

	public static void argumentsSetup(String[] args) {

		filePath = args[FILE_PATH];

		if (args.length != 3) {
			System.err.println("Wrong number of arguments.");
			System.err.println("Usage: java -jar app.jar [input file] [employee name] [employee name]");
			System.exit(EXIT_FAILURE);
		}

		firstEmployeeName = normalizeName(args[EMPLOYEE_1]);
		secondEmployeeName = normalizeName(args[EMPLOYEE_2]);

		logger.info("Reading file " + filePath);
		logger.info(String.format("Finding shortest path between \"%s\" (\"%s\") and \"%s\" (\"%s\")",
				firstEmployeeName,
				args[EMPLOYEE_1], secondEmployeeName, args[EMPLOYEE_2]));
	}

	public static void checkEmployeesFound(String[] args, Optional<Employee> employee1,
			Optional<Employee> employee2) {
		final var employee1NotFound = employee1.isEmpty();
		final var employee2NotFound = employee2.isEmpty();

		if (employee1NotFound || employee2NotFound) {
			System.err.println(String.format("Employee %s (%s) not found in input file %s",
					firstEmployeeName,
					args[EMPLOYEE_1], filePath));
			System.err.println(String.format("Employee %s (%s) not found in input file %s",
					secondEmployeeName,
					args[EMPLOYEE_2], filePath));
			System.exit(EXIT_FAILURE);
		}
	}

	public static void main(String[] args) throws Exception {

		argumentsSetup(args);

		try {
			List<Employee> employees = Parser.parse(filePath);
			Hierarchy hierarchy = Hierarchy.of(employees);
			PathFinder pathFinder = new PathFinder(hierarchy);

			Optional<Employee> employee1 = employees.stream()
					.filter(employee -> normalizeName(employee.name())
							.equalsIgnoreCase(firstEmployeeName))
					.findFirst();

			Optional<Employee> employee2 = employees.stream()
					.filter(employee -> normalizeName(employee.name())
							.equalsIgnoreCase(secondEmployeeName))
					.findFirst();

			checkEmployeesFound(args, employee1, employee2);

			// if we're here, we have valid input
			pathFinder.findShortestPath(employee1.get(), employee2.get());
			System.out.println(pathFinder.toString());

			System.exit(EXIT_SUCCESS);

		} catch (IOException e) {
			System.err.println(e.getMessage());
			System.exit(EXIT_FAILURE);
		}
	}
}
